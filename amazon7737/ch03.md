$5 + 10CHF = $10 (환율이 2:1일 경우)
~~$5 X 2 - $10~~
amount를 private으로 만들기
~~Dollar 부작용?~~
Money 반올림?
**equals()**
hashCode()


지금의 Dollar 객체같이 객체를 값처럼 쓸 수 있는데 이것을 값 객체 패턴(value object pattern)이라고 한다.

값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다

수표가 하나 있는데 여기에 $5를 설정하고 또 다른 수표에도 아까 설정했던 $5를 설정했다고 치자.
그러나, 첫번째 수표와 두번째 수표가 서로 값이 변하도록 연관되면 안된다.

누군가는 $7를 원한다 하면 새로운 객체를 만들어야 할 것이다.

값 객체는 equals() 로 구현해야 하기에 todo 에 추가
테이블 키로 쓸 생각이라면 hashCode() 를 같이 구현해야 한다

```java
public void testEquality() {
  assertTrue(new Dollar(5).equals(new Dollar(5));
}

public boolean equals(Object object) {
  return true;
}

```

위 equals 를 가짜로 구현하는 방법을 사용한 이유
---

우리 둘 다 사실은 True가 '5 == 5 ' 라는 것을 알고, 이것은 다시 'amount == 5' 이며, 결국은 'amount == dollar.amount' 임을 안다. 만약 이런 단계를 밟아간다면, 나는 가장 신중한 세 번째 방법인 삼각 측량 전략을 보여주지 못하게 될 것 같다.

만약 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 있고 각 수신국이 신호의 방향을 알고 있다면, 이 정보들만으로 충분히 신호의 거리와 방위를 알 수 있다
(당신이 나보다 삼각법에 대해 더 잘 기억하고 있다면)

이러한 계산법을 삼각측량 이라고 한다.

삼각측량을 이용하려면 예제가 두 개 이상 있어야만 코드를 일반화할 수 있다

테스트 코드와 모델 코드 사이의 중복을 잠깐만 무시하자 두 번째 예가 좀 더 일반적인 해를 필요로 할 때, 오로지 그때만 비로소 일반화한다

자, 삼각측량을 하기 위해 두 번째 예제가 필요하다 $5 != $6 을 해보는게 어떨까?

---

삼각측량을 조금 더 까놓고 말하면 일반화를 얘기하는 것 같다

이떄는 true가 되어야 될꺼고 어쩔때는 false가 되어야 될껀데 이러한 두가지 경우의 수 정도만 찾아두면
바로 일반화한 코드를 만들어 낼 수 있다는 것 같다.

---

저자는 삼각측량은 조금 이상한 면도 있다고 한다.
그래서 어떻게 리팩토링해야하는지 전혀 감이 안올 때만 삼각 측량을 이용한다고 한다.

코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현한다

왜 한번에 끝낼 수 있는 일을 두고 또 다른 테스트를 만들어야 겠냐?

그럼에도, 설계를 어떻게 해야할지 전혀 떠오르지 않는다면 삼각측량은 문제를 조금 다른 방향에서 생각해볼 기회를 제공한다

지금 설계하는 프로그램이 어떤 변화 가능성을 지원해야 할까? 몇몇 부분을 변경시켜보면 답이 좀 더 명확해질 것이다.

---

하지만 반례가 갑자기 생각난거다. 널 값이나 다른 객체들이 들어가서 비교된다면 어떻게 될까?

이런 상황은 일반적이긴 하지만 당장 필요하지 않으니 todo에 추가만 해두자.

Equal null
Equal object

검토
---

- 우리의 디자인 패턴(값 객체) 이 하나의 또 다른 오퍼레이션을 암시한다는 걸 알아챘다.
- 해당 오퍼레이션을 테스트했다
- 해당 오퍼레이션을 간단히 구현했다
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다
- 두 경우를 모두 수용할 수 있도록 리팩토링했다

